# Especificação de CI/CD e IaC para o Projeto Cortexa

## Objetivo

Este documento especifica a estratégia completa de CI/CD e Infraestrutura como Código (IaC) para o projeto Cortexa. O objetivo é estabelecer um pipeline seguro, automatizado e resiliente para o deploy das funções Lambda na AWS, utilizando GitHub Actions e Terraform, com suporte a múltiplos ambientes e práticas modernas de DevOps.

## Visão Geral da Arquitetura DevOps

### 1. Ambientes de Implantação
- **Development (dev)**
  - Ambiente para testes de integração contínuos
  - Deploys automáticos a partir da branch `develop`
  - Limites de custo rigorosos e cleanup automático
  
- **Staging (stg)**
  - Ambiente espelho da produção
  - Deploys automáticos após aprovação manual
  - Usado para testes de aceitação e performance

- **Production (prod)**
  - Ambiente de produção
  - Deploy somente após aprovação múltipla
  - Monitoramento em tempo real e alertas

### 2. Estrutura do Estado Terraform

```hcl
terraform/
├── environments/
│   ├── dev/
│   │   ├── main.tf
│   │   ├── variables.tf
│   │   └── backend.tf
│   ├── staging/
│   │   └── ...
│   └── prod/
│       └── ...
├── modules/
│   ├── lambda/
│   │   ├── main.tf
│   │   ├── variables.tf
│   │   └── outputs.tf
│   ├── monitoring/
│   └── networking/
└── global/
    └── remote_state.tf
```

## Pipelines de CI/CD

### 1. Pipeline de Integração Contínua (`ci.yml`)

```yaml
name: Continuous Integration
on:
  pull_request:
    branches: [develop, staging, main]

jobs:
  validate:
    name: Validate and Test
    runs-on: ubuntu-latest
    steps:
      - name: Code Quality
        uses: super-linter/super-linter@v5
        env:
          VALIDATE_PYTHON: true
          VALIDATE_TERRAFORM: true
      
      - name: Security Scan
        uses: snyk/actions/python@master
        with:
          args: --severity-threshold=high
      
      - name: Unit Tests
        run: |
          pip install -r requirements-dev.txt
          pytest tests/ --cov=src/ --cov-fail-under=90
      
      - name: Infrastructure Validation
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false
        run: |
          for env in dev staging prod; do
            cd terraform/environments/$env
            terraform init -backend=false
            terraform validate
            cd -
          done

  plan:
    needs: validate
    strategy:
      matrix:
        environment: [dev, staging, prod]
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_READONLY }}
          aws-region: ${{ vars.AWS_REGION }}
      
      - name: Terraform Plan
        id: plan
        run: |
          cd terraform/environments/${{ matrix.environment }}
          terraform init
          terraform plan -detailed-exitcode -no-color -out=tfplan
        continue-on-error: true
      
      - name: Post Plan to PR
        uses: actions/github-script@v6
        if: github.event_name == 'pull_request'
        with:
          script: |
            const output = `### Terraform Plan for ${{ matrix.environment }}
            \`\`\`diff
            ${process.env.PLAN}
            \`\`\`
            `;
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })
```

### 2. Pipeline de Deploy para Desenvolvimento (`cd-develop.yml`)

```yaml
name: Deploy to Development
on:
  push:
    branches: [develop]

jobs:
  deploy_dev:
    name: Deploy to Dev
    environment:
      name: development
      url: https://api-dev.cortexa.com
    runs-on: ubuntu-latest
    
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_DEV }}
          aws-region: ${{ vars.AWS_REGION }}
      
      - name: Build Lambda Packages
        run: |
          ./scripts/build.sh --environment dev
          
      - name: Deploy Infrastructure
        working-directory: terraform/environments/dev
        run: |
          terraform init
          terraform apply -auto-approve
          
      - name: Run Integration Tests
        env:
          API_URL: ${{ steps.deploy.outputs.api_url }}
        run: pytest tests/integration/

      - name: Cleanup Old Resources
        run: ./scripts/cleanup-dev.sh --older-than 7d
```

### 3. Pipeline de Deploy para Staging (`cd-staging.yml`)

```yaml
name: Deploy to Staging
on:
  push:
    branches: [staging]

jobs:
  deploy_staging:
    name: Deploy to Staging
    environment:
      name: staging
      url: https://api-stg.cortexa.com
    
    steps:
      - name: Performance Tests
        run: |
          k6 run load-tests/
          
      - name: Deploy with Canary
        working-directory: terraform/environments/staging
        run: |
          terraform init
          terraform apply -var="deployment_strategy=canary" -auto-approve
          
      - name: Monitor Deployment
        uses: ./.github/actions/monitor-deployment
        with:
          environment: staging
          duration: 15m
          error-rate-threshold: 1%
          
      - name: Rollback on Failure
        if: failure()
        run: terraform apply -var="deployment_strategy=rollback" -auto-approve
```

### 4. Pipeline de Deploy para Produção (`cd-production.yml`)

```yaml
name: Deploy to Production
on:
  release:
    types: [published]

jobs:
  deploy_production:
    name: Deploy to Production
    environment:
      name: production
      url: https://api.cortexa.com
    
    concurrency: production
    
    steps:
      - name: Verify Release Tag
        run: |
          [[ "${{ github.event.release.tag_name }}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]] || exit 1
          
      - name: Create Backup
        run: |
          aws lambda list-functions | jq -r '.Functions[].FunctionName' | \
          xargs -I {} aws lambda get-function --function-name {} > backup/{}
          
      - name: Gradual Deployment
        working-directory: terraform/environments/prod
        run: |
          # Deploy to 10% of traffic
          terraform apply -var="traffic_weight=0.1" -auto-approve
          
          # Monitor for 15 minutes
          ./scripts/monitor.sh --duration 15m --threshold 0.1%
          
          # Deploy to 50% of traffic
          terraform apply -var="traffic_weight=0.5" -auto-approve
          
          # Monitor for 15 minutes
          ./scripts/monitor.sh --duration 15m --threshold 0.1%
          
          # Deploy to 100% of traffic
          terraform apply -var="traffic_weight=1.0" -auto-approve
          
      - name: Verify Deployment
        run: |
          curl -f ${API_URL}/health
          pytest tests/smoke/ --environment prod
          
      - name: Notify Stakeholders
        if: always()
        uses: ./.github/actions/notify
        with:
          status: ${{ job.status }}
          version: ${{ github.event.release.tag_name }}
```

## Módulos Terraform

### 1. Módulo Lambda (`modules/lambda/main.tf`)

```hcl
variable "function_name" {}
variable "handler" {}
variable "runtime" {}
variable "source_dir" {}
variable "environment_variables" { type = map(string) }
variable "memory_size" { default = 128 }
variable "timeout" { default = 30 }

resource "aws_lambda_function" "this" {
  filename         = data.archive_file.lambda_zip.output_path
  function_name    = var.function_name
  role            = aws_iam_role.lambda_exec.arn
  handler         = var.handler
  runtime         = var.runtime
  memory_size     = var.memory_size
  timeout         = var.timeout

  environment {
    variables = var.environment_variables
  }

  tracing_config {
    mode = "Active"
  }
}

resource "aws_cloudwatch_log_group" "this" {
  name              = "/aws/lambda/${var.function_name}"
  retention_in_days = 14
}

output "function_name" {
  value = aws_lambda_function.this.function_name
}

output "function_arn" {
  value = aws_lambda_function.this.arn
}
```

### 2. Módulo de Monitoramento (`modules/monitoring/main.tf`)

```hcl
variable "function_name" {}
variable "alert_topic_arn" {}

resource "aws_cloudwatch_metric_alarm" "errors" {
  alarm_name          = "${var.function_name}-errors"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "2"
  metric_name        = "Errors"
  namespace          = "AWS/Lambda"
  period             = "300"
  statistic          = "Sum"
  threshold          = "1"
  alarm_description  = "This metric monitors lambda function errors"
  alarm_actions      = [var.alert_topic_arn]

  dimensions = {
    FunctionName = var.function_name
  }
}

resource "aws_cloudwatch_metric_alarm" "duration" {
  alarm_name          = "${var.function_name}-duration"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "2"
  metric_name        = "Duration"
  namespace          = "AWS/Lambda"
  period             = "300"
  statistic          = "Average"
  threshold          = "10000"
  alarm_description  = "This metric monitors lambda execution duration"
  alarm_actions      = [var.alert_topic_arn]

  dimensions = {
    FunctionName = var.function_name
  }
}
```

## Scripts de Suporte

### 1. Script de Build (`scripts/build.sh`)

```bash
#!/bin/bash
set -e

ENVIRONMENTS=("dev" "staging" "prod")
FUNCTIONS=("ingest_function" "query_function" "openai_embedding_proxy")

# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --environment)
      DEPLOY_ENV="$2"
      shift 2
      ;;
    *)
      echo "Unknown option: $1"
      exit 1
      ;;
  esac
done

# Validate environment
if [[ ! " ${ENVIRONMENTS[@]} " =~ " ${DEPLOY_ENV} " ]]; then
  echo "Invalid environment. Must be one of: ${ENVIRONMENTS[*]}"
  exit 1
fi

# Create build directory
BUILD_DIR="build/${DEPLOY_ENV}"
mkdir -p "$BUILD_DIR"

# Build each function
for func in "${FUNCTIONS[@]}"; do
  echo "Building $func for $DEPLOY_ENV environment..."
  
  # Create temporary directory
  TEMP_DIR=$(mktemp -d)
  
  # Copy function files
  cp "src/${func}/main.py" "$TEMP_DIR/"
  cp "src/${func}/requirements.txt" "$TEMP_DIR/" 2>/dev/null || true
  
  # Install dependencies if any
  if [ -f "$TEMP_DIR/requirements.txt" ]; then
    pip install -r "$TEMP_DIR/requirements.txt" -t "$TEMP_DIR/"
  fi
  
  # Create zip package
  (cd "$TEMP_DIR" && zip -r "${BUILD_DIR}/${func}.zip" .)
  
  # Cleanup
  rm -rf "$TEMP_DIR"
done

echo "Build completed successfully for $DEPLOY_ENV environment"
```

### 2. Script de Monitoramento (`scripts/monitor.sh`)

```bash
#!/bin/bash
set -e

# Parse command line arguments
DURATION="5m"
THRESHOLD="1.0"

while [[ $# -gt 0 ]]; do
  case $1 in
    --duration)
      DURATION="$2"
      shift 2
      ;;
    --threshold)
      THRESHOLD="$2"
      shift 2
      ;;
    *)
      echo "Unknown option: $1"
      exit 1
      ;;
  esac
done

# Convert duration to seconds
duration_seconds=$(echo "$DURATION" | sed 's/m/*60/;s/h/*3600/;s/d/*86400/' | bc)
end_time=$((SECONDS + duration_seconds))

echo "Starting monitoring for $DURATION (threshold: $THRESHOLD%)"

while [ $SECONDS -lt $end_time ]; do
  # Get error rate from CloudWatch
  error_rate=$(aws cloudwatch get-metric-statistics \
    --namespace AWS/Lambda \
    --metric-name Errors \
    --dimensions Name=FunctionName,Value="${FUNCTION_NAME}" \
    --start-time $(date -u -v-5M "+%Y-%m-%dT%H:%M:%SZ") \
    --end-time $(date -u "+%Y-%m-%dT%H:%M:%SZ") \
    --period 300 \
    --statistics Sum \
    --query "Datapoints[0].Sum" \
    --output text)
  
  if (( $(echo "$error_rate > $THRESHOLD" | bc -l) )); then
    echo "Error rate ($error_rate%) exceeds threshold ($THRESHOLD%)"
    exit 1
  fi
  
  sleep 60
done

echo "Monitoring completed successfully"
```

## Práticas de Segurança e Manutenção

### 1. Gestão de Secrets

- Usar AWS Secrets Manager para credenciais
- Rotação automática de secrets
- Auditoria de acesso aos secrets

### 2. Monitoramento e Alertas

- CloudWatch Dashboards por ambiente
- Alertas de custo e performance
- Logs centralizados

### 3. Disaster Recovery

- Backups automáticos do estado Terraform
- Procedimento documentado de rollback
- Plano de recuperação de desastres

### 4. Manutenção Contínua

- Atualização regular de dependências
- Revisão periódica de permissões
- Testes de recuperação de desastres

## Conclusão

Esta especificação estabelece uma base sólida para um pipeline de CI/CD moderno e seguro, com suporte a múltiplos ambientes e práticas avançadas de DevOps. A estrutura modular do Terraform e os scripts de suporte fornecem automação consistente e confiável para o deployment das funções Lambda do projeto Cortexa.
